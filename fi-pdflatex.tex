%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
  digital,     %% The `digital` option enables the default options for the
               %% digital version of a document. Replace with `printed`
               %% to enable the default options for the printed version
               %% of your thesis.
%%  color,       %% Uncomment these lines (by removing the %% at the
%%               %% beginning) to use color in the printed version of your
%%               %% document
  oneside,     %% The `oneside` option enables one-sided typesetting,
               %% which is preferred if you are only going to submit a
               %% digital version of your thesis. Replace with `twoside`
               %% for double-sided typesetting if you are planning to
               %% also print your thesis. For double-sided typesetting,
               %% use at least 120 g/m² paper to prevent show-through.
  nosansbold,  %% The `nosansbold` option prevents the use of the
               %% sans-serif type face for bold text. Replace with `sansbold` to use sans-serif type face for bold text.
  nocolorbold, %% The `nocolorbold` option disables the usage of the
               %% blue color for bold text, instead using black. Replace with `colorbold` to use blue for bold text.
  lof,         %% The `lof` option prints the List of Figures. Replace
               %% with `nolof` to hide the List of Figures.
  lot,         %% The `lot` option prints the List of Tables. Replace
               %% with `nolot` to hide the List of Tables.
]{fithesis4}
%% The following section sets up the locales used in the thesis.
\usepackage[resetfonts]{cmap} %% We need to load the T2A font encoding
\usepackage[T1,T2A]{fontenc}  %% to use the Cyrillic fonts with Russian texts.
\usepackage[
  main=english, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the thesis
                %% in either Czech or Slovak, respectively.
  english, german, czech, slovak %% The additional keys allow
]{babel}        %% foreign texts to be typeset as follows:
%%
%%   \begin{otherlanguage}{german}  ... \end{otherlanguage}
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%%
%% The following section sets up the metadata of the thesis.
\thesissetup{
    date        = \the\year/\the\month/\the\day,
    university  = mu,
    faculty     = fi,
    type        = bc,
    department  = Department of Machine Learning and Data Processing,
    author      = {Bc. Maxmilián Šeffer},
    gender      = m,
    advisor     = {doc. Ing. Václav Oujezský, Ph.D.},
    title       = {Smart Timesheet App},
    TeXtitle    = {Smart Timesheet Application},
    keywords    = {TO DO keywords},
    TeXkeywords = {keyword1, keyword2, \ldots},
    abstract    = {%
        This thesis explores the potential of audio transcription technology to simplify time tracking for employees working in the field. The goal is to develop a cloud-based application that allows employees to log their working hours by recording audio descriptions of their tasks, specifying the client and project. This recorded speech is then transcribed into text and converted into structured database entries. The research evaluates the reliability and practicality of this approach in real-world conditions.
        
        In addition to automated transcription, the application provides features for replaying audio recordings, manually editing and managing entries, and exporting data for managerial review. By simplifying the logging process, the solution aims to minimize forgetfulness of employees and improve accuracy of work record while offering employees an efficient way to track their work.
    },
    thanks      = {%
      I would like to thank doc. Ing. Václav Oujezský, Ph.D., for his guidance and leadership throughout this thesis. My thanks also go to Bc. Ondřej Zelinka, with whom I collaborated as he was working simultaneously on a web version of the front-end. I am also grateful to Roman Kalous for his support and cooperation on behalf of the company.
    },
    bib         = example.bib,
    %% Remove the following line to use the JVS 2018 faculty logo.
    facultyLogo = fithesis-fi,
}
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight markup
\usepackage{listings} %% Source code highlighting
\lstset{
  basicstyle      = \ttfamily,
  identifierstyle = \color{black},
  keywordstyle    = \color{blue},
  keywordstyle    = {[2]\color{cyan}},
  keywordstyle    = {[3]\color{olive}},
  stringstyle     = \color{teal},
  commentstyle    = \itshape\color{magenta},
  breaklines      = true,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}
\usepackage[babel]{csquotes} %% Context-sensitive quotation marks

\begin{document}
%% The \chapter* command can be used to produce unnumbered chapters:
\chapter*{Introduction}
%% Unlike \chapter, \chapter* does not update the headings and does not
%% enter the chapter to the table of contents. If we want correct
%% headings and a table of contents entry, we must add them manually:
\markright{\textsc{Introduction}}
\addcontentsline{toc}{chapter}{Introduction}
TODO

\begin{otherlanguage}{czech}
TODO
\end{otherlanguage}

\chapter{System Requirements}

\section{Introduction}

In order to develop a practical and effective cloud-based audio transcription system for time tracking, a comprehensive requirements analysis is essential. This phase establishes a clear understanding of the functionalities and constraints that the software must adhere to, ensuring alignment with user needs and business objectives. The analysis focuses on defining user roles, identifying functional and non-functional requirements, and outlining key technical considerations.

The goal of this analysis is to create a structured framework that guides the development of the Smart Timesheet Application. Through discussions with potential users, stakeholders, and domain experts, the analysis highlights both explicit and implicit needs, as well as potential challenges that may arise during implementation.

\section{Users}

The primary users of the Smart Timesheet Application are mainly field employees. These users frequently switch between tasks and clients throughout the day. Their primary need is a quick, reliable, and intuitive method to log their working hours and task details in real-time without requiring a traditional computer interface. They benefit from hands-free audio logging that ensures accuracy and minimizes forgotten details.

\section{Functional Requirements}

The functional requirements define the core capabilities of the Smart Timesheet Application, ensuring that it meets user expectations and performs its intended tasks efficiently. These requirements specify the system's behavior in terms of services, tasks, and functions that users can perform.

This section also integrates the functional requirements as outlined by the development team at Devbalance. These include support for multiple languages, offline functionality, voice-to-text processing, and generative AI for text analysis. The integration of these elements helps ensure the application’s performance aligns with the needs of its users while supporting real-time synchronization, data accuracy, and ease of use.

To clearly outline the expected functionality, the requirements are presented in the form of use cases. Each use case describes a specific interaction between the user and the system, defining the prerequisites, the sequence of steps, and the expected outcome.

The use cases are not listed by priority but instead grouped at the same level of abstraction for clarity. While some use cases could be decomposed into more detailed subcases, this document keeps them at a high level to maintain readability. Detailed business logic, rules, and dependencies will be enforced through integration tests in the system’s codebase, avoiding redundant specifications in this document.

The core functional requirements of the Smart Timesheet Application revolve around efficient, voice-enabled time tracking, cloud-based data storage, secure authentication, and multi-language support. The application must accommodate hands-free logging while ensuring that users can review, edit, and manage their work records with minimal friction. Additionally, robust data security mechanisms must be in place to guarantee data integrity and user privacy. The system should also provide offline and online synchronization, as well as support for generative AI to analyze and summarize work entries.

\subsection{Voice-to-Text Recording and Storage}

\noindent \textbf{Actors:} Employee

\noindent \textbf{Prerequisites:} User is authenticated

\noindent \textbf{Description:}  
Employees can record audio descriptions of their work in either Czech or English. The system transcribes the audio into text, uses a trained AI model to extract key information, and stores the recording in a cloud-based NoSQL database. The extracted data is parsed into a structured database entry, first saved locally and then persistently in the cloud.

\noindent \textbf{Steps:}
\begin{enumerate}
    \item Employee initiates an audio recording in the application.
    \item Employee verbally describes the work performed, using either Czech or English.
    \item The system automatically detects the language of the recording if not manually selected.
    \item System uploads the recording to the cloud.
    \item Transcription service processes the audio and converts it into text.
    \item AI model analyzes the transcribed text, extracting key information such as client, task, activity, and duration.
    \item System structures the extracted data into a work record.
    \item Work record is temporarily saved locally on the device.
    \item Work record is uploaded to the cloud-based NoSQL database.
    \item The employee receives a notification upon completion of the transcription and data entry.
\end{enumerate}

\subsection{Adding Work Records Manually}

\noindent \textbf{Actors:} Employee

\noindent \textbf{Prerequisites:} User is authenticated

\noindent \textbf{Description:}  
Employees can manually enter work records if they prefer not to use audio transcription or if they wish to edit a previously recorded work entry.

\noindent \textbf{Steps:}
\begin{enumerate}
    \item Employee navigates to the manual work entry interface.
    \item Employee inputs details such as client, project, and task description.
    \item Work entry is saved to the cloud database.
\end{enumerate}

\subsection{Reviewing and Editing Work Entries}

\noindent \textbf{Actors:} Employee

\noindent \textbf{Prerequisites:} User is authenticated, work entries exist

\noindent \textbf{Description:}  
Employees can review and edit their past work records, including both manually entered and transcribed entries.

\noindent \textbf{Steps:}
\begin{enumerate}
    \item Employee accesses the work log history.
    \item Employee selects a work entry to review.
    \item Employee can replay the original audio recording (if available).
    \item If necessary, employee edits the transcription or manually entered details.
    \item Updated entry is saved to the cloud database.
\end{enumerate}

\subsection{Searching, Filtering, and Sorting Work Entries}

\noindent \textbf{Actors:} Employee

\noindent \textbf{Prerequisites:} User is authenticated, work entries exist

\noindent \textbf{Description:}  
Employees can search for and filter work logs based on specific criteria such as date, project, or client. Sorting of records is also available.

\noindent \textbf{Steps:}
\begin{enumerate}
    \item Employee accesses the search and filter interface.
    \item Employee selects criteria for filtering (e.g., date range, client, project).
    \item Employee selects criteria for sorting (e.g., by date, project, or client).
    \item System retrieves and displays the matching work entries.
\end{enumerate}

\subsection{Cloud-Based Data Storage and Organization}

\noindent \textbf{Actors:} System

\noindent \textbf{Prerequisites:} Work entries exist

\noindent \textbf{Description:}  
Work records are securely stored in a cloud-based NoSQL database. Employees can access their records from any authenticated device.

\noindent \textbf{Steps:}
\begin{enumerate}
    \item Work entries are saved in a structured format in the cloud.
    \item System ensures data is organized for efficient retrieval.
    \item Employees can easily view, sort, and access their stored records.
\end{enumerate}

\subsection{User Authentication and Access Control}

\noindent \textbf{Actors:} Employee

\noindent \textbf{Prerequisites:} None

\noindent \textbf{Description:}  
Authentication and access control ensure that only authorized users can log in and access their respective data.

\noindent \textbf{Steps:}
\begin{enumerate}
    \item Employee attempts to log in via Microsoft authentication.
    \item System verifies credentials through Firebase Authentication.
    \item System checks the employee’s email domain.
    \item If the domain is authorized, the employee is granted access to their records.
    \item System ensures that employees from different domains cannot view or modify each other's records.
\end{enumerate}

\subsection{Offline Audio Logging and Synchronization}

\noindent \textbf{Actors:} Employee

\noindent \textbf{Prerequisites:} User is authenticated, no internet connection available

\noindent \textbf{Description:}  
Employees can record work descriptions offline. Once an internet connection is restored, the system automatically uploads and processes the recordings, ensuring that data is synchronized across devices.

\noindent \textbf{Steps:}
\begin{enumerate}
    \item Employee records an audio entry while offline.
    \item System stores the recording locally on the device.
    \item Once an internet connection is restored, the system automatically uploads and processes the recording.
    \item Transcribed entry is added to the work log.
\end{enumerate}

\subsection{Receiving Notifications}

\noindent \textbf{Actors:} Employee

\noindent \textbf{Prerequisites:} User is authenticated, relevant event occurs

\noindent \textbf{Description:}  
Employees receive notifications when important events occur, such as transcription completion or record updates.

\noindent \textbf{Steps:}
\begin{enumerate}
    \item System detects an event requiring a notification (e.g., transcription complete).
    \item System generates a notification message.
    \item Employee receives a push notification or email alert.
\end{enumerate}

\subsection{Multilingual User Interface}

\noindent \textbf{Actors:} Employee

\noindent \textbf{Prerequisites:} User is authenticated

\noindent \textbf{Description:}  
Employees can switch between Czech and English for the user interface, allowing the application to support a multilingual user base.

\noindent \textbf{Steps:}
\begin{enumerate}
    \item Employee navigates to the settings menu.
    \item Employee selects the preferred language (Czech or English).
    \item The user interface updates to the selected language.
\end{enumerate}

\section{Non-Functional Requirements}

While functional requirements define what the system must do, non-functional requirements ensure that the system operates effectively under real-world conditions. These requirements specify qualities such as performance, security, usability, and scalability, ensuring that the application remains reliable, efficient, and user-friendly over time.  

The Smart Timesheet Application is designed to accommodate employees working in various environments, including fieldwork where hands-free operation and offline functionality may be necessary. Additionally, as a cloud-based solution, the system must provide seamless data synchronization and high availability, while ensuring that sensitive work records remain secure and private.  

The following sections outline the essential characteristics that the system must meet to provide a smooth, secure, and scalable experience.

\subsection{Performance and Reliability}  
The transcription process does not need to be instant, but users must be notified upon completion so they can review and verify the results. The system must handle multiple concurrent users and organizations without performance degradation.  

While a constant internet connection is not required, users must be able to record audio offline. The recorded audio should be queued and automatically processed when the device reconnects to the internet. Additionally, the system should ensure that no data is lost in case of connection interruptions.

\subsection{Usability and Accessibility}  
The user interface should be designed with simplicity and ease of use in mind, requiring minimal training. Hands-free operation should be a priority, with voice commands and simple touch interactions allowing users to log work efficiently without needing extensive manual input.  

The system should also provide clear visual and auditory feedback to confirm actions. Text should be minimized for core functionality but available for advanced configurations and settings.

\subsection{Security and Compliance}  
All user data must be securely stored and transmitted using encryption. The application must comply with GDPR and other relevant data protection regulations, ensuring that users’ personal and work-related information is not exposed or misused.  

Additionally, access control mechanisms must prevent unauthorized users from accessing or modifying work records.

\subsection{Scalability}  
The system must be designed to support a growing number of users and organizations. As adoption increases, performance should remain stable, and the backend infrastructure must be capable of handling increased storage and processing demands without requiring significant downtime or maintenance.

\subsection{Cross-Platform Support}  
The application must be available on both Android and iOS platforms, ensuring that employees can access and use the system regardless of their device. The mobile application should maintain consistent functionality and usability across different devices and operating system versions.

\subsection{Logging and Audit Trails}  
The system must maintain detailed audit logs for key operations, including the creation and modification of work records. Specifically, changes to work entries, authentication events, and offline-to-online data synchronization must be logged.  

These logs should provide administrators and developers with insights into potential issues, user errors, or security concerns.

\subsection{Failure Handling and Reporting}  
The application must include mechanisms for detecting and reporting failures. If an entry fails to synchronize due to network issues or a transcription error, the user must be notified, and the failure must be logged for further debugging.  

Complete system failures should be automatically reported to the development team, enabling proactive maintenance and issue resolution.

\subsection{Database Support}  
The system should efficiently handle up to a million records and a million audio files without performance degradation.  

\subsection{Performance Optimization}  
The system must be optimized for fast data loading and processing, even with large volumes of records. Voice recordings should be quickly accessible for playback, ensuring a responsive user experience.

\subsection{Storage Capacity}  
The system must efficiently manage storage for millions of short voice files of medium quality. It should automatically optimize storage usage while ensuring quick access to the files when needed.

\subsection{Voice Recordings Security}  
Voice recordings must be securely encrypted both during transmission and at rest. The system should ensure that sensitive voice data remains protected from unauthorized access or tampering.

\subsection{Multilingual Support}  
The application must support two language variants (Czech and English) for the user interface and for processing text from voice recordings. This includes ensuring that the transcription, AI models, and interface components can handle both languages seamlessly.

\subsection{Testability and Logging}  
The system must include detailed logging of user actions and error reports that facilitate testing and debugging. Logs should capture important events such as the creation and modification of records, authentication attempts, and synchronization statuses.

\subsection{Data Backup}  
The system must support automatic backup of both structured data and voice recordings on a regular basis. This ensures data integrity and recovery in case of system failures or data loss events.

\subsection{UI Responsiveness}  
The user interface must be responsive and provide a consistent user experience across devices, including smartphones, tablets, and desktops. The application should adapt seamlessly to different screen sizes and resolutions to ensure usability in both small and large devices.

    
\shorthandoff{-}
\begin{markdown}[
  citationNbsps,
  citations,
  definitionLists,
  fencedCode,
  hashEnumerators,
  inlineNotes,
  notes,
  pipeTables,
  rawAttribute,
  tableCaptions,
]
   
\end{markdown}
\shorthandon{-}

\chapter{Market Analysis}

\section{Introduction}
The need for efficient time-tracking solutions has led to the development of various tools aimed at helping businesses and employees manage work hours effectively. Many existing solutions rely on manual entry, mobile applications, or automated tracking features. However, there are still gaps in usability, accuracy, and hands-free operation, particularly for field employees who require a more seamless and automated way to log their time.

\section{Existing Solutions}

Several time-tracking applications currently serve businesses, each with strengths and limitations:

\begin{itemize}
\item \textbf{Clockify}: A widely used time-tracking tool that provides manual entry, timers, and integration with various project management tools. While powerful, it requires manual input or interaction with a timer, which may not be ideal for field employees who need a hands-free option.
\item \textbf{Toggl Track}: Offers intuitive time tracking with automation features, but still relies on user interaction to start and stop time logs. It lacks built-in voice transcription for work entry.
\item \textbf{Hubstaff}: Includes GPS tracking and automated timesheets, making it useful for remote teams, but does not focus on voice-based logging.
\item \textbf{TSheets by QuickBooks}: Provides detailed time-tracking features and payroll integration but requires manual input or GPS tracking, with no emphasis on voice-based automation.
\end{itemize}

\section{Strengths and weaknesses of existing solutions}

\begin{itemize}  
    \item \textbf{Strengths:} Most existing solutions provide cloud-based tracking, integrations with payroll and project management tools, and mobile accessibility. In addition, these applications are often highly optimized and feature rich, ensuring a streamlined user experience. However, many of their most valuable features are restricted behind paywalls, necessitating costly subscriptions. Moreover, businesses frequently lack control over the application's functionality and long-term availability, making them dependent on third-party providers. Organizations require a time-tracking solution that offers reliability and stability without the risk of unexpected feature limitations, forced upgrades, or service discontinuation.  

    Another significant limitation is the absence of dedicated audio-to-work-entry functionality in existing solutions. Although some applications permit audio attachments as supplementary notes, they do not provide automated transcription or structured conversion of voice recordings into work entries. As a result, users must rely on manual data entry or timers, which may be inefficient for field employees who require a seamless and hands-free method of logging work hours.  

    \item \textbf{Weaknesses:} The majority of existing solutions rely on manual input, timers, or GPS tracking, which may be impractical for employees working in dynamic field environments. Although some applications incorporate voice-based logging, these implementations are generally limited to note taking rather than full transcription and structured work entry generation. Consequently, such solutions function more as auxiliary documentation tools rather than complete work-logging systems, failing to address the specific needs of professionals who require accurate and automated time tracking.

\end{itemize}

\shorthandoff{-}
\begin{markdown}[
  citationNbsps,
  citations,
  definitionLists,
  fencedCode,
  hashEnumerators,
  inlineNotes,
  notes,
  pipeTables,
  rawAttribute,
  tableCaptions,
]
\end{markdown}
\shorthandon{-}


\shorthandoff{-}
\begin{markdown}[
  citationNbsps,
  citations,
  definitionLists,
  fencedCode,
  hashEnumerators,
  inlineNotes,
  notes,
  pipeTables,
  rawAttribute,
  tableCaptions,
]

# Design

## Overview

The Smart Timesheet Application is designed to provide a scalable and efficient solution for employees to log and manage their work records using audio-based logging and manual entry. The system must handle multiple companies, ensuring that user authentication, data storage, and processing are both secure and scalable.

A fundamental design decision was to offload authentication and user management to Microsoft accounts. Since the application is expected to be used across different companies, managing user accounts internally would introduce unnecessary complexity. By leveraging Microsoft's identity management services, authentication and access control are handled externally, ensuring a seamless and secure login experience while eliminating the need for manual account management.

The backend of the system is entirely cloud-based, ensuring high availability, real-time synchronization, and scalability. A NoSQL cloud database stores all timesheet entries, while audio recordings are uploaded to cloud storage, making them accessible from both mobile and web applications. Various approaches were considered, including self-hosted database solutions such as MongoDB or SQLite with a shared repository layer. While these could provide flexibility in local or hybrid deployments, they introduce challenges such as scalability limitations, synchronization complexity, and increased maintenance overhead. A cloud-first approach was chosen to provide automatic scaling, seamless access across devices, and minimal operational burden.

A key feature of the application is converting audio logs into structured timesheet entries. This is achieved through external Open API endpoints that handle both speech-to-text transcription and text-to-timesheet parsing. Running a lightweight AI model directly on mobile devices was considered as an alternative, but this approach was ultimately discarded due to performance constraints, high battery consumption, difficulty in maintaining AI models across different devices, and inconsistent processing power across smartphones. By utilizing cloud-based AI services, the system ensures accurate and scalable transcription without compromising device performance.

The primary interface for users is a mobile application, available for both Android and iOS. The mobile app allows employees to record audio logs, manually enter work records, and review their timesheet history. The user experience is designed to be minimalistic and intuitive, prioritizing voice-based interactions and quick data entry.

In addition to the mobile app, there is also a web-based application, which provides an alternative way for users to access their timesheet data. The web application was developed independently by Bc. Ondřej Zelinka as a separate implementation. However, since both applications were meant to be interchangeable from the view of the user, the design and core functionalities of the entire system were discussed before and through their implementation, then aligned to ensure consistency between platforms. While both applications were implemented separately, they share many technical details related to backend services, including transcription models, prompts, database structures, and user group management. This ensures that both platforms provide a unified experience and operate on the same fundamental principles.

In conclusion, the system was designed with a strong emphasis on improving user experience, scalability, and operational efficiency. By utilizing Microsoft accounts for authentication, the application ensures secure and simplified access management, particularly important given the multi-organization use case. Cloud-based storage for data and audio recordings guarantees high availability, scalability, and seamless real-time synchronization across devices. The integration of external AI services for transcription offloads resource-intensive processing to a third party, reducing system complexity without introducing a critical backend service that would require additional maintenance and most importantly, availability management.

\end{markdown}

\section{System Architecture}

The system architecture is designed with a clear focus on scalability, efficiency, and cross-platform functionality. After careful consideration of the system requirements, along with some prototyping, it has been decided that the core functionality will be supported by the following components.

The development process has been conducted concurrently a mobile and a web interface\footnote{The web application is not a part of this thesis and has been developed by a fellow student, Bc. Ondřej Zelinka}. Although developed as separate projects, they share many common features and functionalities. Notably, the UI/UX designs have been discussed and aligned across both platforms. A shared set of supporting services ensures that both the mobile app and the web interface operate seamlessly, offering a consistent experience. These shared services include the entire Firebase stack, which provides authentication, data storage, and standardization of timesheet data formats. Furthermore, the OpenAI endpoints and associated prompts are employed as common resources for both applications and saved in Firebase storage. This design allows the user to utilize both applications simultaneously with a single account, ensuring a unified experience across platforms.

\subsection{System Components Overview}

The core components of the system include:

\begin{itemize}
    \item \textbf{Android/iOS Application} – A mobile application available on both Android and iOS platforms, providing users with access to the system's functionalities.
    \item \textbf{Web Application} – Developed by a fellow student, Bc. Ondřej Zelinka, as a separate project. This web-based platform offers similar functionalities to the mobile application, allowing users to interact with the system via a web browser.
    \item \textbf{OpenAI API}
    \begin{itemize}
        \item \textbf{Speech-to-Text Endpoint} – Used for transcribing audio recordings to text.
        \item \textbf{Text-to-Timesheet Endpoint} – Converts the transcribed text into a structured timesheet format.
    \end{itemize}
    \item \textbf{Firebase Services}
    \begin{itemize}
        \item \textbf{Firebase Storage} – Used for storing audio files.
        \item \textbf{Firestore Database} – A NoSQL database used to store static content such as prompts, activities, clients, and projects, as well as dynamic data such as timesheets.
        \item \textbf{Firebase Authentication} – A service used for managing user authentication across both platforms.
    \end{itemize}
    \item \textbf{Azure App} – Provides finer control over login procedures via Microsoft accounts, as this is the primary method of authentication, as required by Devbalance.
\end{itemize}

Several additional services and supporting components are used and further discussed in the Deployment chapter. 

\shorthandon{-}

\chapter{Technologies used}

The Smart Timesheet Application is built using modern technologies that ensure scalability, performance, and security. The choice of technologies directly supports the functional and non-functional requirements, enabling efficient development and a seamless user experience. The key technologies used in the application include Flutter, Firebase, and Microsoft Authentication.

\section{Flutter}

Flutter is a UI framework developed by Google that allows for the development of natively compiled applications for mobile, web, and desktop from a single codebase. The Smart Timesheet Application uses Flutter to create cross-platform applications for both Android and iOS devices.

Flutter utilizes the Dart programming language, which offers a rich set of features and provides strong typing, asynchronous programming, and fast performance. By using Flutter, the application is able to maintain consistent functionality and high performance across different platforms.

The core advantage of Flutter lies in its hot reload feature, which allows developers to instantly see changes in the code reflected in the application without needing to restart the app. This significantly speeds up development time and improves the testing cycle.

\section{Firebase}

Firebase is a comprehensive platform for building web and mobile applications, offered by Google. It provides a set of tools that simplifies backend development, handling key tasks such as data storage, authentication, and crash reporting.

\subsection{Firestore}

Firestore is a NoSQL cloud database that is used in the Smart Timesheet Application to store work records and user data. Firestore allows for scalable and flexible storage, offering real-time synchronization of data across all devices. This is crucial for ensuring that the data is always up-to-date across different devices, especially when working offline or in poor network conditions.

Data in Firestore is stored in collections of documents. Each document contains fields, where data is stored as key-value pairs. This structure allows easy querying and retrieval of user data, making it suitable for the dynamic nature of the application.

\subsection{Firebase Storage}

Firebase Storage is used for storing and serving large files, such as voice recordings. The Smart Timesheet Application uses Firebase Storage to securely store audio files that users upload as part of their work records. The integration of Firebase Storage ensures that these files are available for download and playback in a fast and secure manner.

\subsection{Crashlytics}

Firebase Crashlytics is a powerful crash reporting tool integrated into the Smart Timesheet Application to track, report, and fix crashes in real-time. Crashlytics provides detailed reports about the nature and frequency of crashes, allowing developers to quickly identify and resolve critical issues, improving the app's stability.

\subsection{Firebase Authentication}

Firebase Authentication is used to manage user sign-in and authentication within the application. The Smart Timesheet Application utilizes Microsoft authentication to allow users to sign in securely using their Microsoft credentials. This simplifies the authentication process and ensures that user accounts are managed efficiently.

Firebase Authentication supports a wide range of identity providers, including email/password login, social media logins, and custom authentication methods. The flexibility of Firebase Authentication allows for easy integration of additional identity providers if required in the future, ensuring that the application remains scalable.

\shorthandoff{-}
\begin{markdown}[
  citationNbsps,
  citations,
  definitionLists,
  fencedCode,
  hashEnumerators,
  inlineNotes,
  notes,
  pipeTables,
  rawAttribute,
  tableCaptions,
]
\end{markdown}
\shorthandon{-}

\chapter{Implementation}
\shorthandoff{-}
\begin{markdown}[
  citationNbsps,
  citations,
  definitionLists,
  fencedCode,
  hashEnumerators,
  inlineNotes,
  notes,
  pipeTables,
  rawAttribute,
  tableCaptions,
]

## Software Architecture

Flutter by default does not impose strict guidelines on how code should be structured, nor does it mandate the separation of application layers. Flutter uses Dart as its primary programming language, and what would traditionally be a separate view model—often implemented in a different language—is represented here simply as a special class called a `Widget`. This approach is both an advantage and a disadvantage: it enables rapid development and keeps the technology stack minimal, but it also allows, and in some cases even encourages, poor software architecture practices.

Unlike many other platforms, it is entirely possible to implement the entire business logic and all views of an application in a single `.dart` file. As a result, it is crucial for developers to be disciplined and to establish a coherent software architecture early in the development cycle.

### MVC Pattern

The Model-View-Controller (MVC) pattern separates a system into three distinct parts, each with a different responsibility~[@mdnMVC]:

- **Model** — Contains all business logic and data.
- **View** — Displays data to the user.
- **Controller** — Manages the manipulation of the model.

This separation enhances the modularity of the code, making it easier to modify, test, and maintain.

Examples of systems that use MVC include multi-page applications and frameworks like Symfony.

### Extended MVC Pattern

The application uses an extended, layered variation of the MVC pattern. Since Flutter does not enforce architectural boundaries, maintaining this structure is entirely the developer's responsibility. The key layers are:

- **Model** — Defines the objects and data structures used throughout the app.
- **Service** — Contains the business logic and manages operations such as logging.
- **Controller** — Manages application state and delegates most operations to its corresponding service. In this project, controllers are referred to as **providers** due to naming conventions associated with using `ChangeNotifier`; the controllers also manage the application's state and expose it to other components—hence the term *Provider*.
- **View** — Defines the user interface.

### Project Directory Structure

Organizing a Flutter project's directory structure is pivotal for maintaining scalability, readability, and ease of collaboration. While Flutter does not enforce a specific directory layout, adopting a consistent approach is essential, especially as the application grows in complexity.

In this project, I've decided to use a **feature-first structure**. This approach organizes the code by features rather than technical layers ~[@flutterStateMgmt2].

#### Advantages

- **Improved Navigation**: The feature-first structure makes it easier to navigate the codebase by grouping all files related to a specific feature together.
- **Simplified Refactoring**: Refactoring is more straightforward because related files are encapsulated within individual features, reducing the risk of affecting unrelated parts of the codebase.
- **Scalability**: As the application grows, new features can be added without disrupting the overall structure, which is crucial for large projects.

#### Disadvantages

- **Potential for Duplication**: Shared components between features can lead to code duplication, as each feature might contain similar files for different functionalities.
- **Complexity in Shared Resources**: Managing common utilities or services that span multiple features requires careful planning to avoid redundancy and ensure maintainability.

\end{markdown}
\begin{figure}[h]
  \begin{center}
    \begin{minipage}{.8\textwidth}
      \begin{verbatim}
lib/
+-- src/
    +-- features/
        +-- audio_playback/
        |   +-- data/
        |   +-- services/
        |   +-- providers/
        |   +-- ui/
        +-- audio_recording/
        +-- audio_transcription/
        +-- auth/
        +-- settings/
        +-- work_records/
    +-- common/
    +-- core/
    +-- firebase_options.dart
    +-- main.dart
      \end{verbatim}
    \end{minipage}
  \end{center}
  \caption{Project directory structure}
  \label{fig:project_directory}
\end{figure}

\begin{markdown}[
  citationNbsps,
  citations,
  definitionLists,
  fencedCode,
  hashEnumerators,
  inlineNotes,
  notes,
  pipeTables,
  rawAttribute,
  tableCaptions,
]

### State Management

There are multiple approaches to handling state management in Flutter. In many frameworks, a specific method of state management is prescribed. However, because Flutter supports a wide range of platforms, it is not surprising that state management is largely delegated to plugins and third-party libraries~[@flutterStateMgmt].

Among the available options~[@flutterStateMgmt], three methods are generally considered industry standards:

- `StatefulWidget`'s `setState` method^[Official documentation: https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html]
- `Provider` package^[Provider package on pub.dev: https://pub.dev/packages/provider]
- `Riverpod` package^[Official Riverpod site: https://riverpod.dev/]

In the timesheet application, the `Provider` package is used to manage all states that are, or could feasibly be, required by multiple components. The `ChangeNotifier` class provided by the package simplifies listening for changes across the application.

Meanwhile, `StatefulWidget`'s `setState` is utilized whenever the state is local to a single component, typically when it only affects the current view or user interface.

## Prompt Engineering

In the smart timesheet app, prompt engineering was critical to accurately transform transcribed audio into structured timesheet data. The challenge of supporting multiple languages, particularly English and Czech, required careful handling of transcription metadata. If the spoken language and metadata did not match, the model would attempt to transcribe and translate, leading to suboptimal results.

To avoid this, we created separate optimized prompts for English and Czech. These prompts ensure accurate transcription by setting a clear language context, enabling the model to focus on transcribing rather than translating. This approach has been key to improving transcription quality and minimizing errors. The prompts were crafted according to best practices for prompt engineering, such as providing clear instructions and limiting ambiguity. For instance, when transcribing in Czech, the prompt includes a direct instruction to interpret and format the text in a specific, structured manner, minimizing the model’s cognitive load. This specificity helps in reducing errors that might arise due to incorrect translations or misunderstood context, especially in professional terms related to time tracking and work descriptions [@openaiPrompt].

Furthermore, we used specific formatting to improve the model’s response consistency. By carefully choosing appropriate instructions and ensuring that the language metadata matched the transcription language, we were able to optimize the prompts for both languages. This resulted in a significant improvement in the accuracy of the data transformation process, with reduced discrepancies between spoken language and expected results.

\end{markdown}
\shorthandon{-}

\chapter{Deployment}
\shorthandoff{-}
\begin{markdown}[
  citationNbsps,
  citations,
  definitionLists,
  fencedCode,
  hashEnumerators,
  inlineNotes,
  notes,
  pipeTables,
  rawAttribute,
  tableCaptions,
]

## Version control

Versioning plays a crucial role in the management and delivery of software, particularly in collaborative and iterative development environments. It provides a structured way to track and communicate changes, enhancements, and fixes, thus facilitating better coordination among team members and stakeholders, and ensuring consistency across distributed versions of the software.

In the development of the smart timesheet app, we adopted the semantic versioning standard, a widely recognized system designed to convey meaning about the underlying code with each version identifier~[@semver]. The standard uses the format `MAJOR.MINOR.PATCH`, where:

- `MAJOR` version increases indicate incompatible API changes,
- `MINOR` version increases add functionality in a backward-compatible manner, and
- `PATCH` version increases represent backward-compatible bug fixes

In our project, version numbers follow the following pattern:

```
MAJOR.MINOR.PATCH+BUILD_METADATA
```

To give a clearer example:
```
0.11.0+1745075692
```

The core `0.11.0` adheres to the semantic versioning scheme, while the suffix `+1745075692` serves as build metadata. This metadata, represented as a Unix timestamp, enables differentiation of individual builds down to the level of Git commits, which is particularly helpful for internal testing and continuous integration workflows. A Unix timestamp is a numeric representation of the number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), and is commonly used in computing for time tracking~[@mdnUnixTime].

The build metadata is automatically appended by a GitLab CI pipeline, which injects a timestamp or commit-based hash during the build process. This automation ensures that each distributed version can be traced back to the exact source state, facilitating debugging, auditing, and reproducibility.

Development leading up to the final delivery of this thesis is considered work-in-progress. The first stable release — version `1.0.0` — is planned to coincide with the project's completion and will signify a stable, production-ready build~[@semver].

## CI/CD

TODO: Pipeline steps and responsibilities

## Crashlytics

TODO: How logging and access to those logs is implemented

## App distribution

TODO: How app is distributed to testers

\end{markdown}
\shorthandon{-}

\chapter{Testing and Validation}
\shorthandoff{-}
\begin{markdown}[
  citationNbsps,
  citations,
  definitionLists,
  fencedCode,
  hashEnumerators,
  inlineNotes,
  notes,
  pipeTables,
  rawAttribute,
  tableCaptions,
]
  % TODO: Document testing phases, including unit tests, integration tests, and user feedback.
\end{markdown}
\shorthandon{-}

\chapter{Conclusion and Future Work}
\shorthandoff{-}
\begin{markdown}[
  citationNbsps,
  citations,
  definitionLists,
  fencedCode,
  hashEnumerators,
  inlineNotes,
  notes,
  pipeTables,
  rawAttribute,
  tableCaptions,
]

TODO: What's next?

\end{markdown}
\shorthandon{-}

\appendix %% Start the appendices.
\chapter{Appendix A: Additional Information}
TODO appendices

\end{document}
